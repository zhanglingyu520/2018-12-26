1.关于样式
    最后webpack会把所有版块CSS合并在一起，如果编写样式的时候命名以及一些处理不够规范，很容易导致样式之间的冲突！
    解决：使用LESS/SASS预编译语言，每个版块最外层的样式类名保证唯一性（命名规则：版块名+BOX等修饰词），把当前版块下的子内容都嵌套到这个里面。需要公用的延时写在COMMON中即可。
    =》有一些JS/WEBPACK插件自动进行了版块区分，目的是为了保证CSS不冲突
2.真实项目中并不是所有的组件和redux有关系，所以对于那些和REDUX没有关系的组件，我们不要在CONNECT高阶处理了（同理不需要使用路由中的属性的一些组件，也没必要用withRoute...）,竟可能少使用高阶组件，因为高阶组件都是利用柯理化函数思想，形成闭包嵌套，这样导致很多栈内存不销毁，影响性能！
3.真实项目中，完成数据绑定，我们可以按照以下方案处理：
    方案一：第一次加载组件之前或者之后（willMount/DidMount）,发送AJAX请求，等待数据请求成功后，把请求回来的数据更新组件内部的状态信息（第一次加载的是空数据，第二次更新的时候加载真实的数据）从而重新渲染组件，展示真实的内容
    弊端:在路由切换的时候，当前组件很有可能需要重新加载（组件完成了页面移除到再次展示的过程，这样需要从CONSTRUCTOR从头加载组件），这样就导致，只要路由切换到这个组件，都需要重新发送一次AJAX请求，对于一些不是随时更新数据的组件,这样处理会增加HTTP请求的次数，增重服务器的处理压力！
    
   方案二:每一次加载组件，我们首先验证REDUX中是否存储了展示的信息，如果有,直接从REDUX获取即可，如果没有，发送一个DISPATCH派发，在派发的ACTION CREATOR中基于AJAX获取数据，把获取的数据传递给REDUX，把信息存储到REDUX中，RUDUX中的信息更改，那么用到它的组件也会重新渲染
   弊端：某些特定的案例中会存在一些问题，需要额外处理，例如（在个人中心，A用户登录成功，我们进入个人信息页面，首先会把A的信息存储到REDUX中，这样只要进入到信息页，展示的都是A的信息，不会重新重服务器获取最新的信息，或者是登录的用户已经变为B了，都不会改变），这种情况，我们需要再一些其它操作的时候（例如：重新登录、修改用户信息、退出登陆等操作），都才需要REDUX中存储的个人信息更新才可以！

4.在REUDX-PROMISE中间件使用的时候,ACTION-CREATOR中返回的ACTION对象，传递给REDUCER的ACTION数据（从服务器获取的数据，开始返回的是一个PROMISE）中的属性名必须是payload(严格区分大小写)，只有这样，当PROMISE成功，中间件才会帮我们重新发送一次派发给REDUCER,然后把获取的数据信息更新REDUX容器中的状态！
    可以使用THUNCK中间件的语法
   
        /*        return async dispatch=>{
                   let bannerData=await queryBanner();
                    dispatch({
                        type:TYPES.COURSE_QUERY_BANNER,
                        bannerData
                    })
                };*/
      
        

        `
